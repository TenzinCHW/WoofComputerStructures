/*
   This file was generated automatically by the Mojo IDE version B1.3.5.
   Do not edit this file directly. Instead edit the original Lucid source.
   This is a temporary file and any changes made to it will be destroyed.
*/

module alufn_1 (
    output reg [7:0] out,
    output reg [2:0] zvn,
    input [7:0] a,
    input [7:0] b,
    input [5:0] aLUFN
  );
  
  
  
  reg [7:0] ay;
  
  reg [7:0] bee;
  
  reg [5:0] alufn;
  
  wire [8-1:0] M_adder_out;
  wire [1-1:0] M_adder_z;
  wire [1-1:0] M_adder_v;
  wire [1-1:0] M_adder_n;
  reg [8-1:0] M_adder_a;
  reg [8-1:0] M_adder_b;
  reg [6-1:0] M_adder_aLUFN;
  adder_3 adder (
    .a(M_adder_a),
    .b(M_adder_b),
    .aLUFN(M_adder_aLUFN),
    .out(M_adder_out),
    .z(M_adder_z),
    .v(M_adder_v),
    .n(M_adder_n)
  );
  
  wire [8-1:0] M_mult_out;
  reg [8-1:0] M_mult_a;
  reg [8-1:0] M_mult_b;
  reg [6-1:0] M_mult_aLUFN;
  multiplier_4 mult (
    .a(M_mult_a),
    .b(M_mult_b),
    .aLUFN(M_mult_aLUFN),
    .out(M_mult_out)
  );
  
  wire [8-1:0] M_div_out;
  reg [8-1:0] M_div_a;
  reg [8-1:0] M_div_b;
  reg [6-1:0] M_div_aLUFN;
  divisor_5 div (
    .a(M_div_a),
    .b(M_div_b),
    .aLUFN(M_div_aLUFN),
    .out(M_div_out)
  );
  
  wire [8-1:0] M_shifter_out;
  reg [8-1:0] M_shifter_a;
  reg [3-1:0] M_shifter_b;
  reg [6-1:0] M_shifter_aLUFN;
  shifter_6 shifter (
    .a(M_shifter_a),
    .b(M_shifter_b),
    .aLUFN(M_shifter_aLUFN),
    .out(M_shifter_out)
  );
  
  wire [8-1:0] M_bool_out;
  reg [8-1:0] M_bool_a;
  reg [8-1:0] M_bool_b;
  reg [6-1:0] M_bool_aLUFN;
  boolean_7 bool (
    .a(M_bool_a),
    .b(M_bool_b),
    .aLUFN(M_bool_aLUFN),
    .out(M_bool_out)
  );
  
  wire [8-1:0] M_comparer_out;
  reg [8-1:0] M_comparer_a;
  reg [8-1:0] M_comparer_b;
  reg [6-1:0] M_comparer_aLUFN;
  compare_8 comparer (
    .a(M_comparer_a),
    .b(M_comparer_b),
    .aLUFN(M_comparer_aLUFN),
    .out(M_comparer_out)
  );
  
  always @* begin
    ay = a;
    bee = b;
    alufn = aLUFN;
    M_adder_a = ay;
    M_adder_b = bee;
    M_adder_aLUFN = alufn;
    M_mult_a = ay;
    M_mult_b = bee;
    M_mult_aLUFN = alufn;
    M_div_a = ay;
    M_div_b = bee;
    M_div_aLUFN = alufn;
    M_shifter_a = ay;
    M_shifter_b = bee[0+2-:3];
    M_shifter_aLUFN = alufn;
    M_bool_a = ay;
    M_bool_b = bee;
    M_bool_aLUFN = alufn;
    M_comparer_a = ay;
    M_comparer_b = bee;
    M_comparer_aLUFN = alufn;
    zvn[0+0-:1] = M_adder_z;
    zvn[1+0-:1] = M_adder_v;
    zvn[2+0-:1] = M_adder_n;
    
    case (aLUFN[4+1-:2])
      1'h0: begin
        if (aLUFN[1+0-:1]) begin
          out = M_mult_out;
        end else begin
          if (aLUFN[2+0-:1]) begin
            out = M_div_out;
          end else begin
            out = M_adder_out;
          end
        end
      end
      1'h1: begin
        out = M_bool_out;
      end
      2'h2: begin
        out = M_shifter_out;
      end
      2'h3: begin
        out = M_comparer_out;
      end
      default: begin
        out = 1'h0;
      end
    endcase
  end
endmodule
